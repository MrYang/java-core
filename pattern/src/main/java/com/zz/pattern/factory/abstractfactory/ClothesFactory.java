package com.zz.pattern.factory.abstractfactory;


/**
 * 抽象工厂模式的介绍
 抽象工厂模式提供一个创建一系列或相互依赖的对象的接口，而无需指定它们具体的类。

 抽象工厂模式角色
 抽象工厂模式涉及到的系统角色
 （1）抽象工厂（AbstractFactory）角色：担任这个角色的是工厂方法模式的核心，它是与应用系统的商业逻辑无关的。通常使用Java 接口或者抽象Java 类实现，而所有的具体工厂类必须实现这个Java 接口或继承这个抽象Java 类。
 （2）具体工厂类（Conrete Factory）角色：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适的产品对象的逻辑，而这个逻辑是与应用系统的商业逻辑紧密相关的。通常使用具体Java 类实现这个角色。
 （3）抽象产品（Abstract Product）角色：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。通常使用Java 接口或者抽象Java 类实现这一角色。
 （4）具体产品（Concrete Product）角色：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。这是客户端最终需要的东西，其内部一定充满了应用系统的商业逻辑。通常使用具体Java 类实现这个角色。



 抽象工厂模式的优缺点
 优点：
 （1） 隔离了具体类的生成，使得用户不需要知道什么被创建了。
 （2） 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
 缺点：
 （1）添加新的产品对像时，难以扩展抽象工厂以便生产新种类的产品。

 抽象工厂模式的适用环境
 （1）一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。这对于所有形态的工厂模式都是重要的；
 （2）一个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品；
 （3）同属于同一个产品族的产品是在一起使用的，这一约束必须要在系统的设计中体现出来；
 （4）系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。
 */
public abstract class ClothesFactory {

    abstract UpperClothes createUpperClothes(int chestSize, int height);

    abstract Trousers createTrousers(int waistSize, int height);
}
